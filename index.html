<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Quantum Connect 4</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        @keyframes discDrop {
            0% { transform: translateY(-500px); opacity: 0; }
            80% { transform: translateY(10px); opacity: 1; }
            100% { transform: translateY(0); opacity: 1; }
        }
        
        @keyframes pulse {
            0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 255, 255, 0.7); }
            100% { transform: scale(1.1); box-shadow: 0 0 15px 5px rgba(255, 255, 255, 0.5); }
        }
        
        @keyframes confettiFall {
            0% { transform: translateY(-100vh) rotate(0deg); }
            100% { transform: translateY(100vh) rotate(360deg); }
        }
        
        @keyframes columnHighlight {
            0% { background-color: rgba(255, 255, 255, 0); }
            50% { background-color: rgba(255, 255, 255, 0.2); }
            100% { background-color: rgba(255, 255, 255, 0); }
        }
        
        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }
        
        @keyframes stars {
            from { transform: translateY(0); }
            to { transform: translateY(-100vh); }
        }
        
        @keyframes quantumPulse {
            0% { box-shadow: 0 0 5px 0px rgba(59, 130, 246, 0.5); }
            50% { box-shadow: 0 0 20px 5px rgba(59, 130, 246, 0.8); }
            100% { box-shadow: 0 0 5px 0px rgba(59, 130, 246, 0.5); }
        }
        
        @keyframes quantumOrbit {
            0% { transform: rotate(0deg) translateX(20px) rotate(0deg); }
            100% { transform: rotate(360deg) translateX(20px) rotate(-360deg); }
        }
        
        .disc {
            animation: discDrop 0.5s cubic-bezier(0.25, 0.46, 0.45, 0.94) forwards;
        }
        
        .winning-disc {
            animation: pulse 1s infinite alternate;
        }
        
        .highlight-column {
            animation: columnHighlight 1s infinite;
        }
        
        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0.8;
            animation: confettiFall linear forwards;
        }
        
        .board-bg {
            background: radial-gradient(circle at center, #1e40af 0%, #1e3a8a 100%);
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            position: relative;
            overflow: hidden;
        }
        
        .cell {
            transition: all 0.3s ease;
        }
        
        .cell:hover {
            transform: translateY(-5px);
        }
        
        .player1-disc {
            background: radial-gradient(circle at 30% 30%, #93c5fd, #3b82f6);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(59, 130, 246, 0.5);
        }
        
        .player2-disc {
            background: radial-gradient(circle at 30% 30%, #fca5a5, #ef4444);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(239, 68, 68, 0.5);
        }
        
        .preview-disc {
            opacity: 0.5;
            transition: all 0.2s ease;
        }
        
        .modal-enter {
            animation: modalFadeIn 0.3s forwards;
        }
        
        @keyframes modalFadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }
        
        .theme-option {
            transition: all 0.2s ease;
        }
        
        .theme-option:hover {
            transform: scale(1.1);
        }
        
        .star {
            position: absolute;
            background: white;
            border-radius: 50%;
            animation: stars linear infinite;
        }
        
        .quantum-particle {
            position: absolute;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.8);
            animation: quantumOrbit 4s linear infinite;
        }
        
        .quantum-core {
            position: absolute;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: rgba(59, 130, 246, 0.8);
            animation: quantumPulse 2s infinite;
        }
        
        .floating-btn {
            animation: float 3s ease-in-out infinite;
        }
        
        .power-up {
            transition: all 0.3s ease;
        }
        
        .power-up:hover {
            transform: scale(1.1) rotate(10deg);
        }
        
        .glow {
            filter: drop-shadow(0 0 8px currentColor);
        }
        
        .theme-neon .board-bg {
            background: radial-gradient(circle at center, #6d28d9 0%, #4c1d95 100%);
        }
        
        .theme-neon .player1-disc {
            background: radial-gradient(circle at 30% 30%, #c4b5fd, #8b5cf6);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(139, 92, 246, 0.7);
        }
        
        .theme-neon .player2-disc {
            background: radial-gradient(circle at 30% 30%, #f0abfc, #d946ef);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(217, 70, 239, 0.7);
        }
        
        .theme-ocean .board-bg {
            background: radial-gradient(circle at center, #0891b2 0%, #155e75 100%);
        }
        
        .theme-ocean .player1-disc {
            background: radial-gradient(circle at 30% 30%, #7dd3fc, #0ea5e9);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(14, 165, 233, 0.5);
        }
        
        .theme-ocean .player2-disc {
            background: radial-gradient(circle at 30% 30%, #fda4af, #f43f5e);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(244, 63, 94, 0.5);
        }
        
        .theme-sunset .board-bg {
            background: radial-gradient(circle at center, #ea580c 0%, #9a3412 100%);
        }
        
        .theme-sunset .player1-disc {
            background: radial-gradient(circle at 30% 30%, #fdba74, #f97316);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(249, 115, 22, 0.5);
        }
        
        .theme-sunset .player2-disc {
            background: radial-gradient(circle at 30% 30%, #fcd34d, #f59e0b);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(245, 158, 11, 0.5);
        }
        
        .theme-matrix .board-bg {
            background: radial-gradient(circle at center, #10b981 0%, #065f46 100%);
        }
        
        .theme-matrix .player1-disc {
            background: radial-gradient(circle at 30% 30%, #6ee7b7, #10b981);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(16, 185, 129, 0.7);
        }
        
        .theme-matrix .player2-disc {
            background: radial-gradient(circle at 30% 30%, #f9a8d4, #ec4899);
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.2), 0 0 15px rgba(236, 72, 153, 0.7);
        }
        
        .matrix-code {
            position: absolute;
            color: rgba(16, 185, 129, 0.7);
            font-family: monospace;
            font-size: 14px;
            writing-mode: vertical-rl;
            text-orientation: mixed;
            animation: matrixFall linear infinite;
            text-shadow: 0 0 5px rgba(16, 185, 129, 0.7);
        }
        
        @keyframes matrixFall {
            0% { transform: translateY(-100%); opacity: 0; }
            10% { opacity: 1; }
            90% { opacity: 1; }
            100% { transform: translateY(100%); opacity: 0; }
        }
        
        .power-up-active {
            animation: pulse 0.5s infinite alternate;
        }
    </style>
</head>
<body class="bg-gray-900 text-white min-h-screen flex flex-col items-center justify-center p-4 overflow-hidden">
    <!-- Background elements -->
    <div id="stars-container" class="fixed inset-0 overflow-hidden pointer-events-none"></div>
    <div id="quantum-particles" class="fixed inset-0 overflow-hidden pointer-events-none"></div>
    
    <!-- Settings Panel -->
    <div class="absolute top-4 right-4 bg-gray-800 bg-opacity-80 rounded-lg p-3 shadow-lg z-10 backdrop-blur-sm">
        <div class="flex flex-col space-y-3">
            <button id="theme-toggle" class="flex items-center space-x-2 text-sm hover:text-blue-400 transition-colors">
                <i class="fas fa-sun"></i>
                <span>Light Mode</span>
            </button>
            
            <div class="flex items-center space-x-2">
                <i class="fas fa-volume-up text-sm"></i>
                <input type="range" id="volume-slider" min="0" max="100" value="70"
                        class="w-24 accent-blue-500">
            </div>
            
            <div class="flex items-center space-x-2">
                <i class="fas fa-robot text-sm"></i>
                <select id="difficulty-select" class="bg-gray-700 text-sm rounded px-2 py-1">
                    <option value="0">2 Players</option>
                    <option value="1">Easy AI</option>
                    <option value="2">Medium AI</option>
                    <option value="3">Hard AI</option>
                    <option value="4">Quantum AI</option>
                </select>
            </div>
            
            <div class="flex justify-center space-x-2 pt-1">
                <div class="theme-option w-6 h-6 rounded-full bg-gradient-to-br from-blue-500 to-red-500 border-2 border-white cursor-pointer" data-theme="default"></div>
                <div class="theme-option w-6 h-6 rounded-full bg-gradient-to-br from-purple-500 to-pink-500 cursor-pointer" data-theme="neon"></div>
                <div class="theme-option w-6 h-6 rounded-full bg-gradient-to-br from-green-400 to-blue-500 cursor-pointer" data-theme="ocean"></div>
                <div class="theme-option w-6 h-6 rounded-full bg-gradient-to-br from-yellow-400 to-red-500 cursor-pointer" data-theme="sunset"></div>
                <div class="theme-option w-6 h-6 rounded-full bg-gradient-to-br from-emerald-500 to-pink-500 cursor-pointer" data-theme="matrix"></div>
            </div>
        </div>
    </div>

    <!-- Main Game Container -->
    <div class="max-w-4xl w-full flex flex-col items-center relative z-10">
        <h1 class="text-5xl font-bold mb-2 bg-clip-text text-transparent bg-gradient-to-r from-blue-400 to-purple-500 glow">
            Quantum Connect 4
        </h1>
        
        <div class="flex items-center justify-center space-x-6 mb-4">
            <div class="flex items-center space-x-2">
                <div id="turn-indicator" class="w-5 h-5 rounded-full bg-blue-500 animate-pulse"></div>
                <span id="turn-info" class="font-medium">
                    <span id="player-name" class="text-blue-400">Player 1</span>'s turn
                </span>
            </div>
            
            <div id="timer" class="bg-gray-800 px-3 py-1 rounded-full text-sm">
                <i class="fas fa-clock mr-1"></i>
                <span>0s</span>
            </div>
            
            <div id="power-ups" class="hidden">
                <div class="flex space-x-2">
                    <div id="double-move" class="power-up bg-yellow-500 text-black px-2 py-1 rounded-full text-xs cursor-pointer" title="Double Move">
                        <i class="fas fa-forward mr-1"></i>2x
                    </div>
                    <div id="column-blast" class="power-up bg-red-500 text-white px-2 py-1 rounded-full text-xs cursor-pointer" title="Column Blast">
                        <i class="fas fa-bomb mr-1"></i>Blast
                    </div>
                </div>
            </div>
        </div>
        
        <div class="flex space-x-4 mb-4">
            <div class="stats-item bg-gray-800 px-3 py-1 rounded-full">
                <span class="text-blue-400">Player 1:</span> <span id="player1-wins">0</span>
            </div>
            <div class="stats-item bg-gray-800 px-3 py-1 rounded-full">
                <span class="text-red-400">Player 2:</span> <span id="player2-wins">0</span>
            </div>
            <div class="stats-item bg-gray-800 px-3 py-1 rounded-full">
                <span>Draws:</span> <span id="draws">0</span>
            </div>
        </div>
        
        <div class="flex space-x-3 mb-6">
            <button id="reset-btn" class="bg-blue-600 hover:bg-blue-700 px-4 py-2 rounded-lg transition-colors floating-btn">
                <i class="fas fa-sync-alt mr-2"></i>New Game
            </button>
            <button id="undo-btn" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg transition-colors">
                <i class="fas fa-undo mr-2"></i>Undo
            </button>
            <button id="hint-btn" class="bg-purple-600 hover:bg-purple-700 px-4 py-2 rounded-lg transition-colors">
                <i class="fas fa-lightbulb mr-2"></i>Hint
            </button>
            <button id="player-names-btn" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded-lg transition-colors">
                <i class="fas fa-users mr-2"></i>Names
            </button>
            <button id="power-ups-btn" class="bg-yellow-600 hover:bg-yellow-700 px-4 py-2 rounded-lg transition-colors">
                <i class="fas fa-bolt mr-2"></i>Power-ups
            </button>
        </div>
        
        <!-- Game Board -->
        <div class="board-bg rounded-2xl p-4 relative">
            <div id="board" class="grid grid-cols-7 gap-2 relative"></div>
            
            <!-- Quantum effect overlay -->
            <div id="quantum-overlay" class="absolute inset-0 pointer-events-none opacity-0 transition-opacity duration-500">
                <div class="quantum-core" style="top: 30%; left: 30%;"></div>
                <div class="quantum-particle" style="top: 30%; left: 30%;"></div>
                <div class="quantum-particle" style="top: 30%; left: 30%; animation-delay: 0.5s;"></div>
                <div class="quantum-particle" style="top: 30%; left: 30%; animation-delay: 1s;"></div>
            </div>
        </div>
    </div>

    <!-- Win Modal -->
    <div id="win-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl p-8 max-w-md w-full modal-enter">
            <h2 id="modal-title" class="text-3xl font-bold mb-2 text-center"></h2>
            <p id="modal-message" class="text-center mb-6"></p>
            <div id="modal-stats" class="text-center mb-6"></div>
            <button id="play-again-btn" class="w-full bg-blue-600 hover:bg-blue-700 py-3 rounded-lg font-medium transition-colors">
                Play Again
            </button>
        </div>
    </div>

    <!-- Player Names Modal -->
    <div id="names-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl p-8 max-w-md w-full modal-enter">
            <h2 class="text-2xl font-bold mb-6 text-center">Player Names</h2>
            <div class="space-y-4 mb-6">
                <div>
                    <label for="player1-name" class="block mb-1 text-blue-400">Player 1:</label>
                    <input type="text" id="player1-name" class="w-full bg-gray-700 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
                <div>
                    <label for="player2-name" class="block mb-1 text-red-400">Player 2:</label>
                    <input type="text" id="player2-name" class="w-full bg-gray-700 rounded-lg px-4 py-2 focus:outline-none focus:ring-2 focus:ring-blue-500">
                </div>
            </div>
            <button id="save-names-btn" class="w-full bg-blue-600 hover:bg-blue-700 py-3 rounded-lg font-medium transition-colors">
                Save Names
            </button>
        </div>
    </div>
    
    <!-- Power-ups Modal -->
    <div id="power-ups-modal" class="fixed inset-0 bg-black bg-opacity-70 flex items-center justify-center z-50 hidden">
        <div class="bg-gray-800 rounded-xl p-8 max-w-md w-full modal-enter">
            <h2 class="text-2xl font-bold mb-6 text-center">Power-ups</h2>
            <div class="grid grid-cols-2 gap-4 mb-6">
                <div class="power-up bg-yellow-500 text-black p-4 rounded-lg cursor-pointer flex flex-col items-center" data-power="double">
                    <i class="fas fa-forward text-2xl mb-2"></i>
                    <h3 class="font-bold">Double Move</h3>
                    <p class="text-xs text-center">Place two discs in one turn</p>
                </div>
                <div class="power-up bg-red-500 text-white p-4 rounded-lg cursor-pointer flex flex-col items-center" data-power="blast">
                    <i class="fas fa-bomb text-2xl mb-2"></i>
                    <h3 class="font-bold">Column Blast</h3>
                    <p class="text-xs text-center">Clear an entire column</p>
                </div>
                <div class="power-up bg-purple-500 text-white p-4 rounded-lg cursor-pointer flex flex-col items-center" data-power="gravity">
                    <i class="fas fa-magnet text-2xl mb-2"></i>
                    <h3 class="font-bold">Gravity Shift</h3>
                    <p class="text-xs text-center">Change gravity direction</p>
                </div>
                <div class="power-up bg-green-500 text-white p-4 rounded-lg cursor-pointer flex flex-col items-center" data-power="swap">
                    <i class="fas fa-random text-2xl mb-2"></i>
                    <h3 class="font-bold">Quantum Swap</h3>
                    <p class="text-xs text-center">Swap positions with opponent</p>
                </div>
            </div>
            <button id="close-power-ups-btn" class="w-full bg-gray-700 hover:bg-gray-600 py-3 rounded-lg font-medium transition-colors">
                Close
            </button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // Game constants
            const ROWS = 6;
            const COLS = 7;
            
            // Game state
            let board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
            let currentPlayer = 1;
            let gameActive = true;
            let moveHistory = [];
            let stats = {
                player1Wins: 0,
                player2Wins: 0,
                draws: 0
            };
            let gameStartTime = Date.now();
            let gameTimer;
            let gameTime = 0;
            let playerNames = {
                player1: "Player 1",
                player2: "Player 2"
            };
            let soundEnabled = true;
            let soundVolume = 0.7;
            let aiDifficulty = 0; // 0 = off, 1 = easy, 2 = medium, 3 = hard, 4 = quantum
            let darkMode = true;
            let currentTheme = 'default';
            let activePowerUps = [];
            let powerUpCooldown = false;
            let gravityDirection = 'down'; // 'down', 'up', 'left', 'right'
            
            // DOM elements
            const boardElement = document.getElementById('board');
            const turnInfo = document.getElementById('turn-info');
            const turnIndicator = document.getElementById('turn-indicator');
            const resetBtn = document.getElementById('reset-btn');
            const undoBtn = document.getElementById('undo-btn');
            const hintBtn = document.getElementById('hint-btn');
            const playerNameBtn = document.getElementById('player-names-btn');
            const powerUpsBtn = document.getElementById('power-ups-btn');
            const winModal = document.getElementById('win-modal');
            const namesModal = document.getElementById('names-modal');
            const powerUpsModal = document.getElementById('power-ups-modal');
            const modalTitle = document.getElementById('modal-title');
            const modalMessage = document.getElementById('modal-message');
            const modalStats = document.getElementById('modal-stats');
            const playAgainBtn = document.getElementById('play-again-btn');
            const player1WinsElem = document.getElementById('player1-wins');
            const player2WinsElem = document.getElementById('player2-wins');
            const drawsElem = document.getElementById('draws');
            const timerElem = document.getElementById('timer');
            const playerNameElem = document.getElementById('player-name');
            const themeToggle = document.getElementById('theme-toggle');
            const volumeSlider = document.getElementById('volume-slider');
            const difficultySelect = document.getElementById('difficulty-select');
            const player1NameInput = document.getElementById('player1-name');
            const player2NameInput = document.getElementById('player2-name');
            const saveNamesBtn = document.getElementById('save-names-btn');
            const closePowerUpsBtn = document.getElementById('close-power-ups-btn');
            const powerUpsContainer = document.getElementById('power-ups');
            const quantumOverlay = document.getElementById('quantum-overlay');
            const starsContainer = document.getElementById('stars-container');
            const quantumParticles = document.getElementById('quantum-particles');
            const themeOptions = document.querySelectorAll('.theme-option');
            
            // Audio elements
            const dropSound = new Audio('data:audio/wav;base64,UklGRisAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQcAACBsACBgAFpXUEZIT1heaXJ8gYiKio2KiYJ8dGxkW1FIQDo2My4qJSIgHBkVEQ==');
            const winSound = new Audio('data:audio/wav;base64,UklGRswAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YagAAACAgICEgYB/f3F3ZnR3entxeXt5dYJ8gH98fH5ycXF2eX1/fX17eHt2dHFzcnFvcnRwcHR2c3R2c3R1c3N0cXF0cnBwcnBucG9tb29ucG9tbm9tb25ubnFxcXN0c3N1c3J0cnBxcG5wcG9wbm1vbm1wcG9wc3JydXV1d3V0dnV0dXV1dXNzdHNydXNydHJxc3FxdHJxdXRzdnV0d3V0d3d2eHl3eXp5enx6eoCAgIKEg4OFiIeHiY2MjI6QkJCTkJCSlpOVlpWTlpSTlJOUlY+OkZGOj4+PjY2OiYoAA==');
            const drawSound = new Audio('data:audio/wav;base64,UklGRnAAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YUIAAAB7d3p1dm9xbm1pZ21sYm9pZ29tbnZ0eH17gIGHhoqMj46QlpaWl5qZmZqcmZybmpuZmpqZmZiXlpeSkZONjgAA');
            const buttonSound = new Audio('data:audio/wav;base64,UklGRiQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
            const powerUpSound = new Audio('data:audio/wav;base64,UklGRlQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
            const quantumSound = new Audio('data:audio/wav;base64,UklGRlQAAABXQVZFZm10IBAAAAABAAEARKwAAIhYAQACABAAZGF0YQAAAAA=');
            
            // Initialize game
            initGame();
            
            // Event listeners
            resetBtn.addEventListener('click', resetGame);
            undoBtn.addEventListener('click', undoMove);
            hintBtn.addEventListener('click', showHint);
            playerNameBtn.addEventListener('click', showNamesModal);
            powerUpsBtn.addEventListener('click', showPowerUpsModal);
            playAgainBtn.addEventListener('click', resetGame);
            saveNamesBtn.addEventListener('click', savePlayerNames);
            closePowerUpsBtn.addEventListener('click', closePowerUpsModal);
            themeToggle.addEventListener('click', toggleDarkMode);
            volumeSlider.addEventListener('input', updateVolumeSettings);
            difficultySelect.addEventListener('change', updateDifficulty);
            
            themeOptions.forEach(option => {
                option.addEventListener('click', () => {
                    themeOptions.forEach(opt => opt.classList.remove('border-2', 'border-white'));
                    option.classList.add('border-2', 'border-white');
                    currentTheme = option.dataset.theme;
                    applyColorTheme(currentTheme);
                    localStorage.setItem('colorTheme', currentTheme);
                    
                    // Special effects for matrix theme
                    if (currentTheme === 'matrix') {
                        createMatrixCode();
                    } else {
                        clearMatrixCode();
                    }
                });
            });
            
            // Initialize functions
            function initGame() {
                createStars();
                createQuantumParticles();
                loadSettings();
                createBoard();
                startTimer();
                updateUI();
            }
            
            function createStars() {
                // Clear existing stars
                starsContainer.innerHTML = '';
                
                // Create stars
                for (let i = 0; i < 100; i++) {
                    const star = document.createElement('div');
                    star.className = 'star';
                    
                    // Random size between 1-3px
                    const size = Math.random() * 2 + 1;
                    star.style.width = `${size}px`;
                    star.style.height = `${size}px`;
                    
                    // Random position
                    star.style.left = `${Math.random() * 100}%`;
                    star.style.top = `${Math.random() * 100}%`;
                    
                    // Random opacity
                    star.style.opacity = Math.random();
                    
                    // Random animation duration
                    const duration = Math.random() * 10 + 5;
                    star.style.animationDuration = `${duration}s`;
                    
                    starsContainer.appendChild(star);
                }
            }
            
            function createQuantumParticles() {
                // Clear existing particles
                quantumParticles.innerHTML = '';
                
                // Create quantum particles
                for (let i = 0; i < 5; i++) {
                    const particle = document.createElement('div');
                    particle.className = 'quantum-particle';
                    
                    // Random position
                    particle.style.left = `${Math.random() * 100}%`;
                    particle.style.top = `${Math.random() * 100}%`;
                    
                    // Random animation duration
                    const duration = Math.random() * 5 + 3;
                    particle.style.animationDuration = `${duration}s`;
                    
                    quantumParticles.appendChild(particle);
                }
            }
            
            function createMatrixCode() {
                // Clear existing code
                const existingCode = document.querySelectorAll('.matrix-code');
                existingCode.forEach(code => code.remove());
                
                // Create matrix code rain
                const characters = "01アイウエオカキクケコサシスセソタチツテトナニヌネノハヒフヘホマミムメモヤユヨラリルレロワヲン";
                
                for (let i = 0; i < 20; i++) {
                    const code = document.createElement('div');
                    code.className = 'matrix-code';
                    
                    // Random position
                    code.style.left = `${Math.random() * 100}%`;
                    
                    // Random animation duration
                    const duration = Math.random() * 10 + 5;
                    code.style.animationDuration = `${duration}s`;
                    
                    // Random delay
                    code.style.animationDelay = `${Math.random() * 5}s`;
                    
                    // Generate random characters
                    let text = '';
                    const length = Math.floor(Math.random() * 10) + 5;
                    for (let j = 0; j < length; j++) {
                        text += characters.charAt(Math.floor(Math.random() * characters.length)) + '\n';
                    }
                    code.textContent = text;
                    
                    document.body.appendChild(code);
                }
            }
            
            function clearMatrixCode() {
                const existingCode = document.querySelectorAll('.matrix-code');
                existingCode.forEach(code => code.remove());
            }
            
            function createBoard() {
                boardElement.innerHTML = '';
                
                // Create column overlays for dropping discs
                for (let col = 0; col < COLS; col++) {
                    const columnOverlay = document.createElement('div');
                    columnOverlay.className = 'absolute top-0 h-full flex justify-center';
                    columnOverlay.style.width = 'calc(100% / 7)';
                    columnOverlay.style.left = `${col * (100 / 7)}%`;
                    columnOverlay.dataset.col = col;
                    
                    // Preview disc
                    const previewDisc = document.createElement('div');
                    previewDisc.className = 'preview-disc absolute rounded-full w-12 h-12 -top-16 hidden';
                    previewDisc.classList.add(`player${currentPlayer}-disc`);
                    columnOverlay.appendChild(previewDisc);
                    
                    columnOverlay.addEventListener('mouseover', () => {
                        if (gameActive) {
                            previewDisc.style.display = 'block';
                            previewDisc.className = `preview-disc absolute rounded-full w-12 h-12 -top-16 player${currentPlayer}-disc`;
                            highlightColumn(col);
                        }
                    });
                    
                    columnOverlay.addEventListener('mouseout', () => {
                        previewDisc.style.display = 'none';
                        removeColumnHighlight(col);
                    });
                    
                    columnOverlay.addEventListener('click', () => {
                        if (gameActive && (currentPlayer === 1 || aiDifficulty === 0)) {
                            playSound(buttonSound);
                            dropDisc(col);
                        }
                    });
                    
                    boardElement.appendChild(columnOverlay);
                }
                
                // Create game cells
                for (let row = 0; row < ROWS; row++) {
                    for (let col = 0; col < COLS; col++) {
                        const cell = document.createElement('div');
                        cell.className = 'cell bg-gray-900 rounded-full w-12 h-12 flex items-center justify-center';
                        cell.dataset.row = row;
                        cell.dataset.col = col;
                        
                        // Create empty disc slot
                        const disc = document.createElement('div');
                        disc.className = 'disc absolute rounded-full w-10 h-10 opacity-0';
                        disc.dataset.row = row;
                        disc.dataset.col = col;
                        
                        cell.appendChild(disc);
                        boardElement.appendChild(cell);
                    }
                }
            }
            
            function highlightColumn(col) {
                const cells = document.querySelectorAll(`.cell[data-col="${col}"]`);
                cells.forEach(cell => {
                    cell.classList.add('highlight-column');
                });
            }
            
            function removeColumnHighlight(col) {
                const cells = document.querySelectorAll(`.cell[data-col="${col}"]`);
                cells.forEach(cell => {
                    cell.classList.remove('highlight-column');
                });
            }
            
            function dropDisc(col) {
                // Find the lowest empty row in the column
                let row = -1;
                for (let r = ROWS - 1; r >= 0; r--) {
                    if (board[r][col] === 0) {
                        row = r;
                        break;
                    }
                }
                
                // If column is full, do nothing
                if (row === -1) return;
                
                // Update the board array
                board[row][col] = currentPlayer;
                
                // Find the disc element to animate
                const disc = document.querySelector(`.disc[data-row="${row}"][data-col="${col}"]`);
                
                // Set the disc color based on the current player
                disc.classList.add(`player${currentPlayer}-disc`);
                
                // Add the move to history
                moveHistory.push({ row, col, player: currentPlayer });
                
                // Play drop sound
                playSound(dropSound);
                
                // Start the animation
                disc.style.animation = 'none';
                void disc.offsetWidth; // Trigger reflow
                disc.style.animation = 'discDrop 0.5s forwards';
                disc.style.opacity = '1';
                
                // Check for win or draw after animation completes
                setTimeout(() => {
                    const isWin = checkWin(row, col, currentPlayer);
                    const isDraw = checkDraw();
                    
                    if (isWin) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        highlightWinningCells(isWin);
                        updateStats(`player${currentPlayer}Wins`);
                        
                        // Play win sound
                        playSound(winSound);
                        
                        // Show confetti animation
                        createConfetti();
                        
                        setTimeout(() => {
                            modalTitle.textContent = `${playerNames['player' + currentPlayer]} Wins!`;
                            modalMessage.textContent = `Game completed in ${formatTime(gameTime)}`;
                            modalStats.innerHTML = `
                                <div class="mb-2">${getCurrentStreak()}</div>
                                <div class="text-sm opacity-80">Best time: ${getBestTime()}</div>
                            `;
                            winModal.classList.remove('hidden');
                        }, 600);
                    } else if (isDraw) {
                        gameActive = false;
                        clearInterval(gameTimer);
                        updateStats('draws');
                        
                        // Play draw sound
                        playSound(drawSound);
                        
                        setTimeout(() => {
                            modalTitle.textContent = 'Game Draw!';
                            modalMessage.textContent = `Game completed in ${formatTime(gameTime)}`;
                            modalStats.innerHTML = `
                                <div class="text-sm opacity-80">Best time: ${getBestTime()}</div>
                            `;
                            winModal.classList.remove('hidden');
                        }, 600);
                    } else {
                        // Switch players
                        currentPlayer = currentPlayer === 1 ? 2 : 1;
                        updateUI();
                        
                        // AI move if enabled and it's AI's turn
                        if (aiDifficulty > 0 && currentPlayer === 2 && gameActive) {
                            setTimeout(() => {
                                makeAIMove();
                            }, 500);
                        }
                    }
                }, 500);
            }
            
            function checkWin(row, col, player) {
                // Check horizontal
                let count = 1;
                // Left
                for (let c = col - 1; c >= 0 && board[row][c] === player; c--) count++;
                // Right
                for (let c = col + 1; c < COLS && board[row][c] === player; c++) count++;
                if (count >= 4) return [[row, col], [row, col + (count > 4 ? 3 : count - 1)]];
                
                // Check vertical
                count = 1;
                // Up
                for (let r = row - 1; r >= 0 && board[r][col] === player; r--) count++;
                // Down
                for (let r = row + 1; r < ROWS && board[r][col] === player; r++) count++;
                if (count >= 4) return [[row, col], [row + (count > 4 ? 3 : count - 1), col]];
                
                // Check diagonal (top-left to bottom-right)
                count = 1;
                // Top-left
                for (let r = row - 1, c = col - 1; r >= 0 && c >= 0 && board[r][c] === player; r--, c--) count++;
                // Bottom-right
                for (let r = row + 1, c = col + 1; r < ROWS && c < COLS && board[r][c] === player; r++, c++) count++;
                if (count >= 4) return [[row, col], [row + (count > 4 ? 3 : count - 1), col + (count > 4 ? 3 : count - 1)]];
                
                // Check diagonal (top-right to bottom-left)
                count = 1;
                // Top-right
                for (let r = row - 1, c = col + 1; r >= 0 && c < COLS && board[r][c] === player; r--, c++) count++;
                // Bottom-left
                for (let r = row + 1, c = col - 1; r < ROWS && c >= 0 && board[r][c] === player; r++, c--) count++;
                if (count >= 4) return [[row, col], [row + (count > 4 ? 3 : count - 1), col - (count > 4 ? 3 : count - 1)]];
                
                return false;
            }
            
            function highlightWinningCells(winCoords) {
                const [start, end] = winCoords;
                const [startRow, startCol] = start;
                const [endRow, endCol] = end;
                
                // Determine direction of the win
                const rowDiff = endRow - startRow;
                const colDiff = endCol - startCol;
                
                for (let i = 0; i < 4; i++) {
                    const row = startRow + (rowDiff !== 0 ? i * Math.sign(rowDiff) : 0);
                    const col = startCol + (colDiff !== 0 ? i * Math.sign(colDiff) : 0);
                    
                    const disc = document.querySelector(`.disc[data-row="${row}"][data-col="${col}"]`);
                    if (disc) {
                        disc.classList.add('winning-disc');
                    }
                }
            }
            
            function checkDraw() {
                return board[0].every(cell => cell !== 0);
            }
            
            function resetGame() {
                playSound(buttonSound);
                
                // Reset board
                board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
                currentPlayer = 1;
                gameActive = true;
                moveHistory = [];
                activePowerUps = [];
                powerUpCooldown = false;
                gravityDirection = 'down';
                
                // Reset timer
                gameStartTime = Date.now();
                clearInterval(gameTimer);
                gameTime = 0;
                startTimer();
                
                // Clear board UI
                document.querySelectorAll('.disc').forEach(disc => {
                    disc.className = 'disc absolute rounded-full w-10 h-10 opacity-0';
                    disc.style.animation = '';
                });
                
                // Hide modal
                winModal.classList.add('hidden');
                powerUpsContainer.classList.add('hidden');
                
                // Update UI
                updateUI();
            }
            
            function undoMove() {
                if (moveHistory.length === 0 || !gameActive) return;
                
                playSound(buttonSound);
                
                const lastMove = moveHistory.pop();
                board[lastMove.row][lastMove.col] = 0;
                
                // Reset the disc
                const disc = document.querySelector(`.disc[data-row="${lastMove.row}"][data-col="${lastMove.col}"]`);
                disc.className = 'disc absolute rounded-full w-10 h-10 opacity-0';
                disc.style.animation = '';
                
                // Switch back to previous player
                currentPlayer = lastMove.player;
                
                // If AI is enabled and we're undoing AI's move, undo one more move
                if (aiDifficulty > 0 && currentPlayer === 2 && moveHistory.length > 0) {
                    const aiMove = moveHistory.pop();
                    board[aiMove.row][aiMove.col] = 0;
                    
                    const aiDisc = document.querySelector(`.disc[data-row="${aiMove.row}"][data-col="${aiMove.col}"]`);
                    aiDisc.className = 'disc absolute rounded-full w-10 h-10 opacity-0';
                    aiDisc.style.animation = '';
                    
                    currentPlayer = aiMove.player;
                }
                
                updateUI();
            }
            
            function showHint() {
                if (!gameActive || currentPlayer !== 1 || aiDifficulty === 0) return;
                
                playSound(buttonSound);
                
                // Find the best move for the current player (1)
                const bestMove = findBestMove(1);
                if (bestMove.col !== undefined) {
                    highlightColumn(bestMove.col);
                    
                    // Flash the column a few times
                    let flashCount = 0;
                    const flashInterval = setInterval(() => {
                        const cells = document.querySelectorAll(`.cell[data-col="${bestMove.col}"]`);
                        cells.forEach(cell => {
                            cell.classList.toggle('highlight-column');
                        });
                        
                        flashCount++;
                        if (flashCount >= 6) {
                            clearInterval(flashInterval);
                            removeColumnHighlight(bestMove.col);
                        }
                    }, 300);
                }
            }
            
            function makeAIMove() {
                if (!gameActive || currentPlayer !== 2) return;
                
                let col;
                
                switch (aiDifficulty) {
                    case 1: // Easy AI - random move
                        const availableCols = [];
                        for (let c = 0; c < COLS; c++) {
                            if (board[0][c] === 0) {
                                availableCols.push(c);
                            }
                        }
                        col = availableCols[Math.floor(Math.random() * availableCols.length)];
                        break;
                                        
                    case 2: // Medium AI - basic strategy
                        // First check if AI can win
                        for (let c = 0; c < COLS; c++) {
                            const row = getFirstEmptyRow(c);
                            if (row !== -1) {
                                board[row][c] = 2;
                                if (checkWin(row, c, 2)) {
                                    board[row][c] = 0;
                                    col = c;
                                    break;
                                }
                                board[row][c] = 0;
                            }
                        }
                        
                        // Then check if player can win and block
                        if (col === undefined) {
                            for (let c = 0; c < COLS; c++) {
                                const row = getFirstEmptyRow(c);
                                if (row !== -1) {
                                    board[row][c] = 1;
                                    if (checkWin(row, c, 1)) {
                                        board[row][c] = 0;
                                        col = c;
                                        break;
                                    }
                                    board[row][c] = 0;
                                }
                            }
                        }
                        
                        // Otherwise make a strategic move
                        if (col === undefined) {
                            const centerCol = Math.floor(COLS / 2);
                            if (board[0][centerCol] === 0) {
                                col = centerCol;
                            } else {
                                // Choose a random column
                                const availableCols = [];
                                for (let c = 0; c < COLS; c++) {
                                    if (board[0][c] === 0) {
                                        availableCols.push(c);
                                    }
                                }
                                col = availableCols[Math.floor(Math.random() * availableCols.length)];
                            }
                        }
                        break;
                                        
                    case 3: // Hard AI - minimax algorithm
                        const bestMove = findBestMove(2);
                        col = bestMove.col;
                        break;
                                        
                    case 4: // Quantum AI - advanced with special moves
                        // 30% chance to use a power-up if available
                        if (Math.random() < 0.3) {
                            // Try to use column blast if player is about to win
                            for (let c = 0; c < COLS; c++) {
                                const row = getFirstEmptyRow(c);
                                if (row !== -1) {
                                    board[row][c] = 1;
                                    if (checkWin(row, c, 1)) {
                                        board[row][c] = 0;
                                        // Use column blast to prevent win
                                        useColumnBlast(c);
                                        return;
                                    }
                                    board[row][c] = 0;
                                }
                            }
                            
                            // Otherwise use double move
                            const bestMove = findBestMove(2);
                            if (bestMove.col !== undefined) {
                                dropDisc(bestMove.col);
                                setTimeout(() => {
                                    const secondBest = findBestMove(2);
                                    if (secondBest.col !== undefined) {
                                        dropDisc(secondBest.col);
                                    }
                                }, 300);
                                return;
                            }
                        }
                        
                        // Fall back to minimax if no power-ups used
                        const hardMove = findBestMove(2);
                        col = hardMove.col;
                        
                        // Show quantum effect
                        quantumOverlay.style.opacity = '0.3';
                        setTimeout(() => {
                            quantumOverlay.style.opacity = '0';
                        }, 1000);
                        break;
                }
                
                if (col !== undefined) {
                    dropDisc(col);
                }
            }
            
            function findBestMove(player) {
                // Simple evaluation function
                function evaluateBoard() {
                    let score = 0;
                    
                    // Check horizontal
                    for (let row = 0; row < ROWS; row++) {
                        for (let col = 0; col < COLS - 3; col++) {
                            const window = [board[row][col], board[row][col+1], board[row][col+2], board[row][col+3]];
                            score += evaluateWindow(window, player);
                        }
                    }
                    
                    // Check vertical
                    for (let col = 0; col < COLS; col++) {
                        for (let row = 0; row < ROWS - 3; row++) {
                            const window = [board[row][col], board[row+1][col], board[row+2][col], board[row+3][col]];
                            score += evaluateWindow(window, player);
                        }
                    }
                    
                    // Check diagonal (top-left to bottom-right)
                    for (let row = 0; row < ROWS - 3; row++) {
                        for (let col = 0; col < COLS - 3; col++) {
                            const window = [board[row][col], board[row+1][col+1], board[row+2][col+2], board[row+3][col+3]];
                            score += evaluateWindow(window, player);
                        }
                    }
                    
                    // Check diagonal (top-right to bottom-left)
                    for (let row = 0; row < ROWS - 3; row++) {
                        for (let col = 3; col < COLS; col++) {
                            const window = [board[row][col], board[row+1][col-1], board[row+2][col-2], board[row+3][col-3]];
                            score += evaluateWindow(window, player);
                        }
                    }
                    
                    return score;
                }
                
                function evaluateWindow(window, player) {
                    const opponent = player === 1 ? 2 : 1;
                    let playerCount = 0;
                    let opponentCount = 0;
                    let emptyCount = 0;
                    
                    for (const cell of window) {
                        if (cell === player) playerCount++;
                        else if (cell === opponent) opponentCount++;
                        else emptyCount++;
                    }
                    
                    // Scoring
                    if (playerCount === 4) return 100;
                    else if (playerCount === 3 && emptyCount === 1) return 5;
                    else if (playerCount === 2 && emptyCount === 2) return 2;
                    else if (opponentCount === 3 && emptyCount === 1) return -4;
                    else if (opponentCount === 4) return -100;
                    
                    return 0;
                }
                
                // Get valid columns
                const validCols = [];
                for (let col = 0; col < COLS; col++) {
                    if (board[0][col] === 0) {
                        validCols.push(col);
                    }
                }
                
                // For each valid column, simulate the move and evaluate
                let bestScore = -Infinity;
                let bestCol = validCols[Math.floor(Math.random() * validCols.length)];
                
                for (const col of validCols) {
                    const row = getFirstEmptyRow(col);
                    board[row][col] = player;
                    
                    const score = evaluateBoard();
                    if (score > bestScore) {
                        bestScore = score;
                        bestCol = col;
                    }
                    
                    board[row][col] = 0;
                }
                
                return { col: bestCol, score: bestScore };
            }
            
            function getFirstEmptyRow(col) {
                for (let row = ROWS - 1; row >= 0; row--) {
                    if (board[row][col] === 0) {
                        return row;
                    }
                }
                return -1;
            }
            
            function startTimer() {
                gameStartTime = Date.now();
                gameTimer = setInterval(() => {
                    gameTime = Math.floor((Date.now() - gameStartTime) / 1000);
                    timerElem.querySelector('span').textContent = `${gameTime}s`;
                }, 1000);
            }
            
            function updateUI() {
                // Update turn indicator
                turnIndicator.className = `w-5 h-5 rounded-full animate-pulse ${currentPlayer === 1 ? 'bg-blue-500' : 'bg-red-500'}`;
                playerNameElem.textContent = playerNames[`player${currentPlayer}`];
                playerNameElem.className = currentPlayer === 1 ? 'text-blue-400' : 'text-red-400';
                
                // Update stats display
                player1WinsElem.textContent = stats.player1Wins;
                player2WinsElem.textContent = stats.player2Wins;
                drawsElem.textContent = stats.draws;
                
                // Show power-ups for human player
                if (currentPlayer === 1 && aiDifficulty > 0) {
                    powerUpsContainer.classList.remove('hidden');
                } else {
                    powerUpsContainer.classList.add('hidden');
                }
            }
            
            function updateStats(stat) {
                stats[stat]++;
                localStorage.setItem('connect4Stats', JSON.stringify(stats));
                updateUI();
                
                // Update best time if this was a win
                if (stat !== 'draws') {
                    const bestTimeKey = `bestTime_${aiDifficulty}`;
                    const bestTime = localStorage.getItem(bestTimeKey) || Infinity;
                    if (gameTime < bestTime) {
                        localStorage.setItem(bestTimeKey, gameTime);
                    }
                }
            }
            
            function getBestTime() {
                const bestTimeKey = `bestTime_${aiDifficulty}`;
                const bestTime = localStorage.getItem(bestTimeKey);
                return bestTime ? `${bestTime}s` : 'N/A';
            }
            
            function getCurrentStreak() {
                const streakKey = `streak_${aiDifficulty}`;
                const currentStreak = localStorage.getItem(streakKey) || 0;
                const newStreak = parseInt(currentStreak) + 1;
                localStorage.setItem(streakKey, newStreak);
                return `Winning streak: ${newStreak}`;
            }
            
            function formatTime(seconds) {
                const mins = Math.floor(seconds / 60);
                const secs = seconds % 60;
                return mins > 0 ? `${mins}m ${secs}s` : `${secs}s`;
            }
            
            function createConfetti() {
                const colors = ['#3b82f6', '#ef4444', '#10b981', '#f59e0b', '#8b5cf6'];
                const boardRect = boardElement.getBoundingClientRect();
                
                for (let i = 0; i < 100; i++) {
                    const confetti = document.createElement('div');
                    confetti.className = 'confetti';
                    confetti.style.left = `${Math.random() * boardRect.width + boardRect.left}px`;
                    confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                    confetti.style.animationDuration = `${Math.random() * 3 + 2}s`;
                    confetti.style.width = `${Math.random() * 10 + 5}px`;
                    confetti.style.height = `${Math.random() * 5 + 3}px`;
                    
                    document.body.appendChild(confetti);
                    
                    // Remove after animation
                    setTimeout(() => {
                        confetti.remove();
                    }, 3000);
                }
            }
            
            function showNamesModal() {
                playSound(buttonSound);
                player1NameInput.value = playerNames.player1;
                player2NameInput.value = playerNames.player2;
                namesModal.classList.remove('hidden');
            }
            
            function showPowerUpsModal() {
                playSound(buttonSound);
                powerUpsModal.classList.remove('hidden');
                
                // Add event listeners to power-up buttons
                document.querySelectorAll('[data-power]').forEach(btn => {
                    btn.addEventListener('click', () => {
                        const power = btn.dataset.power;
                        activatePowerUp(power);
                        closePowerUpsModal();
                    });
                });
            }
            
            function closePowerUpsModal() {
                playSound(buttonSound);
                powerUpsModal.classList.add('hidden');
            }
            
            function activatePowerUp(power) {
                if (powerUpCooldown) return;
                
                playSound(powerUpSound);
                
                switch (power) {
                    case 'double':
                        // Allow player to make two moves
                        activePowerUps.push('double');
                        break;
                        
                    case 'blast':
                        // Clear a column
                        activePowerUps.push('blast');
                        break;
                        
                    case 'gravity':
                        // Change gravity direction
                        const directions = ['down', 'up', 'left', 'right'];
                        const currentIndex = directions.indexOf(gravityDirection);
                        gravityDirection = directions[(currentIndex + 1) % directions.length];
                        alert(`Gravity changed to ${gravityDirection}!`);
                        break;
                        
                    case 'swap':
                        // Swap positions with opponent
                        const temp = playerNames.player1;
                        playerNames.player1 = playerNames.player2;
                        playerNames.player2 = temp;
                        updateUI();
                        break;
                }
                
                // Set cooldown
                powerUpCooldown = true;
                setTimeout(() => {
                    powerUpCooldown = false;
                }, 3000);
            }
            
            function useColumnBlast(col) {
                // Clear the entire column
                for (let row = 0; row < ROWS; row++) {
                    board[row][col] = 0;
                    const disc = document.querySelector(`.disc[data-row="${row}"][data-col="${col}"]`);
                    if (disc) {
                        disc.className = 'disc absolute rounded-full w-10 h-10 opacity-0';
                        disc.style.animation = '';
                    }
                }
                
                // Show explosion effect
                const cells = document.querySelectorAll(`.cell[data-col="${col}"]`);
                cells.forEach(cell => {
                    cell.style.transform = 'scale(1.5)';
                    cell.style.opacity = '0';
                    setTimeout(() => {
                        cell.style.transform = '';
                        cell.style.opacity = '';
                    }, 500);
                });
                
                // Switch turns
                currentPlayer = currentPlayer === 1 ? 2 : 1;
                updateUI();
            }
            
            function savePlayerNames() {
                playSound(buttonSound);
                playerNames.player1 = player1NameInput.value || 'Player 1';
                playerNames.player2 = player2NameInput.value || 'Player 2';
                localStorage.setItem('playerNames', JSON.stringify(playerNames));
                namesModal.classList.add('hidden');
                updateUI();
            }
            
            function toggleDarkMode() {
                darkMode = !darkMode;
                document.body.classList.toggle('bg-gray-900', darkMode);
                document.body.classList.toggle('bg-gray-100', !darkMode);
                document.body.classList.toggle('text-white', darkMode);
                document.body.classList.toggle('text-gray-900', !darkMode);
                
                const icon = themeToggle.querySelector('i');
                icon.classList.toggle('fa-moon', !darkMode);
                icon.classList.toggle('fa-sun', darkMode);
                
                themeToggle.querySelector('span').textContent = darkMode ? 'Light Mode' : 'Dark Mode';
                
                localStorage.setItem('darkMode', darkMode);
            }
            
            function updateVolumeSettings() {
                soundVolume = volumeSlider.value / 100;
                localStorage.setItem('soundVolume', soundVolume);
            }
            
            function updateDifficulty() {
                aiDifficulty = parseInt(difficultySelect.value);
                localStorage.setItem('aiDifficulty', aiDifficulty);
                resetGame();
            }
            
            function applyColorTheme(theme) {
                // Remove all theme classes
                document.body.classList.remove('theme-default', 'theme-neon', 'theme-ocean', 'theme-sunset', 'theme-matrix');
                
                // Add the selected theme class
                document.body.classList.add(`theme-${theme}`);
                
                // Special effects for matrix theme
                if (theme === 'matrix') {
                    createMatrixCode();
                } else {
                    clearMatrixCode();
                }
            }
            
            function playSound(sound) {
                if (soundEnabled) {
                    sound.volume = soundVolume;
                    sound.currentTime = 0;
                    sound.play().catch(e => console.log('Sound playback prevented:', e));
                }
            }
            
            function loadSettings() {
                // Load dark mode
                darkMode = localStorage.getItem('darkMode') !== 'false'; // Default to true
                if (darkMode) {
                    document.body.classList.add('bg-gray-900');
                    document.body.classList.add('text-white');
                    const icon = themeToggle.querySelector('i');
                    icon.classList.add('fa-sun');
                    themeToggle.querySelector('span').textContent = 'Light Mode';
                } else {
                    document.body.classList.add('bg-gray-100');
                    document.body.classList.add('text-gray-900');
                    const icon = themeToggle.querySelector('i');
                    icon.classList.add('fa-moon');
                    themeToggle.querySelector('span').textContent = 'Dark Mode';
                }
                
                // Load volume
                const savedVolume = localStorage.getItem('soundVolume');
                if (savedVolume) {
                    soundVolume = parseFloat(savedVolume);
                    volumeSlider.value = soundVolume * 100;
                }
                
                // Load AI difficulty
                const savedDifficulty = localStorage.getItem('aiDifficulty');
                if (savedDifficulty) {
                    aiDifficulty = parseInt(savedDifficulty);
                    difficultySelect.value = aiDifficulty;
                }
                
                // Load player names
                const savedNames = localStorage.getItem('playerNames');
                if (savedNames) {
                    playerNames = JSON.parse(savedNames);
                }
                
                // Load stats
                const savedStats = localStorage.getItem('connect4Stats');
                if (savedStats) {
                    stats = JSON.parse(savedStats);
                }
                
                // Load theme
                const savedTheme = localStorage.getItem('colorTheme');
                if (savedTheme) {
                    currentTheme = savedTheme;
                    applyColorTheme(currentTheme);
                    themeOptions.forEach(option => {
                        if (option.dataset.theme === currentTheme) {
                            option.classList.add('border-2', 'border-white');
                        }
                    });
                }
            }
        });
    </script>
</body>
</html>
